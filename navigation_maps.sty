\ProvidesPackage{navigation_maps}

\RequirePackage{pgf, pgfkeys, tikz}

% Compare strings
\RequirePackage{etoolbox}

% Save min and max values for x and y direction
\pgfkeys{
    /xMin/.is family,
    /xMin/deg/.initial=0,
    /xMin/min/.initial=0,
}

\pgfkeys{
    /xMax/.is family,
    /xMax/deg/.initial=0,
    /xMax/min/.initial=0,
}

\pgfkeys{
    /yMin/.is family,
    /yMin/deg/.initial=0,
    /yMin/min/.initial=0,
}

\pgfkeys{
    /yMax/.is family,
    /yMax/deg/.initial=0,
    /yMax/min/.initial=0,
}


% Arguments: x/y-Axis, axis diff, axis min, axis max
\newcommand{\navAxisSetup}[4]{
    \gdef\navIsXAxis{#1} % 0: x-Axis, other y-Axis
    \gdef\navAxisDiff{#2}
    \gdef\navAxisMin{#3}
    \gdef\navAxisMax{#4}

    % Check 5 step increments
    \pgfmathsetmacro{\minMinInc}{int(\navAxisMin / 25)}
    \pgfmathsetmacro{\minMaxInc}{int(\navAxisMax / 25)}
    \pgfmathsetmacro{\minDiff}{\minMaxInc - \minMinInc}

    \foreach \i in {0, ..., \navAxisDiff}{
        \pgfmathparse{\i}
        \ifnum \pgfmathresult>0

            % Check x/y-Axis
            \pgfmathparse{\navIsXAxis}
            \ifnum \pgfmathresult=0
                \draw (\i - 1, -\navBarSize) rectangle (\i, 0);
            \else
                \draw (-\navBarSize, \i - 1) rectangle (0, \i);
            \fi
        \fi

        \pgfmathsetmacro{\Xstart}{\i + \navAxisMin}
        \pgfmathsetmacro{\currDeg}{int((\i + \navAxisMin) / (60 * 5))}


        % Check for degrees
        \pgfmathsetmacro{\countA}{int(\Xstart / (5 * 60))}
        \pgfmathsetmacro{\countB}{int(5 * 60 * \countA)}
        \pgfmathsetmacro{\DegreeOverlap}{\Xstart - \countB}

        % Show degrees
        \pgfmathparse{int(\DegreeOverlap)}
        \ifnum \pgfmathresult=0
            % Check x/y-Axis
            \pgfmathparse{\navIsXAxis}
            \ifnum \pgfmathresult=0
                \draw[blue] (\i, 0) -- (\i, -\navNumberOffset) node[anchor=north]{\currDeg $^{\circ}$};
            \else
                \draw[blue] (0, \i) -- (-\navNumberOffset, \i) node[anchor=east]{\currDeg $^{\circ}$};
            \fi


        \else
            % Check for minutes
            % Create a mark for every minute
            \pgfmathsetmacro{\minStepSize}{5}
            \navShowMin{}

            \pgfmathparse{int(\minDiff)}
            \ifnum \pgfmathresult>0
                \pgfmathsetmacro{\minStepSize}{5 * 5}
            \fi

            % Show minutes (numbers)
            \navShowMin{\currMin '}
        \fi
    }

    \pgfmathsetmacro{\xCenter}{int(\navAxisDiff / 2)}

    % Set at least one degree value
    \pgfmathsetmacro{\countA}{int(\navAxisMin / (5 * 60))}
    \pgfmathsetmacro{\countB}{int(\navAxisMax / (5 * 60))}
    \pgfmathsetmacro{\DegreeTotalOverlap}{int(\countB - \countA)}

    \pgfmathparse{int(\DegreeTotalOverlap)}
    \ifnum \pgfmathresult=0
        \pgfmathsetmacro{\currDeg}{int(\navAxisMin / (60 * 5))}

        % Check x/y-Axis
        \pgfmathparse{\navIsXAxis}
        \ifnum \pgfmathresult=0
            \draw[black] (\xCenter, -6) node[anchor=north]{\currDeg $^{\circ}$};
        \else
            \draw[black] (-6, \xCenter) node[anchor=east]{\currDeg $^{\circ}$};
        \fi
    \fi
}

\newcommand{\navShowMin}[1]{
    \pgfmathsetmacro{\countOverlapA}{int(\Xstart / \minStepSize)}
    \pgfmathsetmacro{\countOverlapB}{int(\countOverlapA * \minStepSize)}
    \pgfmathsetmacro{\MinOverlap}{\Xstart - \countOverlapB}

    \pgfmathparse{int(\MinOverlap)}
    \ifnum \pgfmathresult=0
        \pgfmathsetmacro{\currMin}{int(int((\i + \navAxisMin) / 5) - (\currDeg * 60))}

        % Check x/y-Axis
        \pgfmathparse{\navIsXAxis}
        \ifnum \pgfmathresult=0
            \draw[black] (\i, 0) -- (\i, -2) node[anchor=north]{#1};
        \else
            \draw[black] (0, \i) -- (-2, \i) node[anchor=east]{#1};
        \fi
    \fi
}

% Arguments: yMin, yMax, xMin, xMax, figure scaling
\newenvironment{nav_map}[5]
% Run at the start
{
    \pgfqkeys{/yMin}{#1}
    \pgfqkeys{/yMax}{#2}
    \pgfqkeys{/xMin}{#3}
    \pgfqkeys{/xMax}{#4}

    \newcommand{\navBarSize}{0.5}
    \newcommand{\navNumberOffset}{4}

    \gdef\navScaling{#5}

    \begin{tikzpicture}[scale=\navScaling]
        % 1 Degree is divided into 60 minutes
        % 1 minute is divided into 5 blocks

        \pgfmathsetmacro{\xMin}{(\pgfkeysvalueof{/xMin/deg} * 60 * 5) + (\pgfkeysvalueof{/xMin/min} * 5)}
        \pgfmathsetmacro{\xMax}{(\pgfkeysvalueof{/xMax/deg} * 60 * 5) + (\pgfkeysvalueof{/xMax/min} * 5)}
        \pgfmathsetmacro{\xDiff}{\xMax - \xMin}

        \pgfmathsetmacro{\yMin}{(\pgfkeysvalueof{/yMin/deg} * 60 * 5) + (\pgfkeysvalueof{/yMin/min} * 5)}
        \pgfmathsetmacro{\yMax}{(\pgfkeysvalueof{/yMax/deg} * 60 * 5) + (\pgfkeysvalueof{/yMax/min} * 5)}
        \pgfmathsetmacro{\yDiff}{\yMax - \yMin}

        % Draw bounding rectangle
        \draw (0, 0) rectangle (\xDiff, \yDiff);


        % -----------------------------------------
        % x Axis
        \navAxisSetup{0}{\xDiff}{\xMin}{\xMax}

        % -----------------------------------------
        % y Axis
        \navAxisSetup{1}{\yDiff}{\yMin}{\yMax}
}
% Run at the end
{
    \end{tikzpicture}
}

\pgfkeys{
    /navConvertCoord/.is family,
    /navConvertCoord/deg/.initial=0,
    /navConvertCoord/min/.initial=0,
    /navConvertCoord/sec/.initial=0,
    /navConvertCoord/x/.initial=0,
    /navConvertCoord/y/.initial=0,
}

% Arguments: isXAxis (x: 0, y: 1), Coords
\newcommand{\navConvertCoords}[2]{
    \pgfkeys{/navConvertCoord/.cd, #2}
    \pgfmathparse{#1}
    \ifnum \pgfmathresult=0
        \pgfmathsetmacro{\xMinConv}{\pgfkeysvalueof{/xMin/deg} * 60 * 5 + \pgfkeysvalueof{/xMin/min} * 5}
        \pgfmathsetmacro{\xRelativeConv}{\pgfkeysvalueof{/navConvertCoord/deg} * 60 * 5 + \pgfkeysvalueof{/navConvertCoord/min} * 5 + \pgfkeysvalueof{/navConvertCoord/sec} / 12 - \xMinConv}

        \pgfkeyssetvalue{/navConvertCoord/x}{\xRelativeConv}
    \else
        \pgfmathsetmacro{\yMinConv}{\pgfkeysvalueof{/yMin/deg} * 60 * 5 + \pgfkeysvalueof{/yMin/min} * 5}
        \pgfmathsetmacro{\yRelativeConv}{\pgfkeysvalueof{/navConvertCoord/deg} * 60 * 5 + \pgfkeysvalueof{/navConvertCoord/min} * 5 + \pgfkeysvalueof{/navConvertCoord/sec} / 12 - \yMinConv}

        \pgfkeyssetvalue{/navConvertCoord/y}{\yRelativeConv}
    \fi
}


% Return the key value from previous coord calculation
\newcommand{\navGetCoord}[1]{
    \pgfkeysvalueof{/navConvertCoord/#1}
}


\pgfkeys{
    /navSymbolSettings/.is family,
    /navSymbolSettings/x/.initial=0,
    /navSymbolSettings/y/.initial=0,
    /navSymbolSettings/scaling/.initial=1,
    /navSymbolSettings/option/.initial=0
}

\pgfkeys{
    /markOptions/.is family,
    % Buoy options: pillar, conical, cylindrical, spherical, ..
    /markOptions/buoy/.store in = \navBuoyOption,
    /markOptions/buoyArea/.store in = \navBuoyArea,
    % cardinalmarks (north, east, south, west), circle (ball), triangle, box (cylinder)
    /markOptions/top/.store in = \navTopMarkings,
    /markOptions/topArea/.store in = \navTopArea,
    /markOptions/x/.initial=0,
    /markOptions/y/.initial=0,
    /markOptions/scaling/.initial=1,
}


% Arguments: navSymbolSettings, markOptions
\newcommand{\navMarks}[2]{
    % Set general navSymbol keys
    \pgfkeys{/navSymbolSettings/.cd, #1}
    \gdef\navA{\pgfkeysvalueof{/navSymbolSettings/x}}
    \gdef\navB{\pgfkeysvalueof{/navSymbolSettings/y}}
    \gdef\navC{\pgfkeysvalueof{/navSymbolSettings/scaling} * 0.5}


    % Set specific mark keys
    % Initial values
    \pgfkeys{/markOptions/.cd, buoy=pillar, buoyArea=, top=, topArea=, scaling=\navC}
    \pgfkeys{/markOptions/.cd, #2}


    % TODO: different marks
    \ifdefstring{\navBuoyOption}{pillar}{
        % Right side
        \draw[\navBuoyArea] (2.5 * \navC + \navA, \navB) -- (1.9 * \navC + \navA, \navB) -- (1.5 * \navC + \navA, 1.8 * \navC + \navB) -- (2.2 * \navC + \navA, 6 * \navC + \navB) --
        % Left Side
        (1.1 * \navC + \navA, 6.3 * \navC + \navB) -- (-0.4 * \navC + \navA, 2.4 * \navC + \navB) -- (-1.9 * \navC + \navA, \navB) -- (-2.5 * \navC + \navA, \navB) -- cycle;


        % Mid line
        \path[draw] (\navA, 0.5 * \navC + \navB) -- (1.65 * \navC + \navA, 6.15 * \navC  + \navB);


        \pgfkeys{/markOptions/.cd, x=\navA + 1.65 * \navC + 0.29 \navC, y=\navB + 6.15 * \navC + 1.17 * \navC}
        \navTopMark

    }

    % Conical bouy:
    \ifdefstring{\navBuoyOption}{conical}{
        % Left side
        \draw[\navBuoyArea] (-1.55 * \navC + \navA, \navB) -- (-1.3 * \navC + \navA, \navB) --
        % Right side
        (0.6 * \navC + \navA, 2.5 * \navC + \navB) -- (1.25 * \navC + \navA, \navB) -- (1.55 * \navC + \navA, \navB) -- cycle;

        \pgfkeys{/markOptions/.cd, x=\navA + 1.2 \navC, y=\navB + 5 * \navC}
        \navTopMark

    }

    % Cylindircal bouy:
    \ifdefstring{\navBuoyOption}{cylindrical}{
        % Left side
        \draw[\navBuoyArea] (-1.75 * \navC + \navA, \navB) -- (-1.4 * \navC + \navA, \navB) -- (-1 * \navC + \navA, 1.85 * \navC + \navB) --
        % Right side
        (1.6 * \navC + \navA, 1.25 * \navC + \navB) -- (1.3 * \navC + \navA, \navB) -- (1.75 * \navC + \navA, \navB) -- cycle;

        \pgfkeys{/markOptions/.cd, x=\navA + 0.5 \navC, y=\navB + 3 * \navC}
        \navTopMark

    }


    % Spherical buoy
    \ifdefstring{\navBuoyOption}{spherical}{
        \coordinate (CircleCenter) at (0.15 * \navC + \navA, 0.7 * \navC + \navB);

        \coordinate (Start) at (0.15 * \navC + \navA + 1.532 * \navC, \navB);
        % \coordinate (End) at (0.15 * \navC + \navA - 1.532 * \navC, \navB);

        \coordinate (Left) at (-2 * \navC + \navA, \navB);
        \coordinate (Right) at (2.5 * \navC + \navA, \navB);

        % Bottom
        \draw (Left) -- (Right);

        % Circle
        \draw (Start) arc[start angle=-40, end angle=220, radius=\navC * 2cm];

        % Mid line
        \path[draw] (\navA, 0.5 * \navC + \navB) -- (1 * \navC + \navA, 3.1 * \navC  + \navB);
    }

    % Spar buoy
    \ifdefstring{\navBuoyOption}{sparbuoy}{
        % Bottom
        \draw (-1.2 * \navC + \navA, \navB) -- (1.2 * \navC + \navA, \navB);

        % Buoy
        % Right side
        \draw[\navBuoyArea] (0.45 * \navC + \navA, 0.217 * \navC + \navB) -- (1.8 * \navC + \navA, 5.5 * \navC + \navB) --
        % Left side
        (1 * \navC + \navA, 5.7 * \navC + \navB) -- (-0.25 * \navC + \navA, 0.48 * \navC + \navB) -- cycle;

        \pgfkeys{/markOptions/.cd, x=\navA + 1.6 * \navC, y=\navB + 6.4 * \navC}
        \navTopMark

    }

    % Barrel buoy
    \ifdefstring{\navBuoyOption}{barrelbuoy}{
        \navBarrelBuoy{\navB}{\navA}{\navC}

    }

    % Superbuoy
    \ifdefstring{\navBuoyOption}{superbuoy}{
        % Left side
        \draw[\navBuoyArea] (-2.75 * \navC + \navA, \navB) -- (-2 * \navC + \navA, \navB) -- (-1.6 * \navC + \navA, 1.25 * \navC + \navB) --
        % Right side
        (1.6 * \navC + \navA, 1.25 * \navC + \navB) -- (2 * \navC + \navA, \navB) -- (2.75 * \navC + \navA, \navB) -- cycle;

    }

    % Mooring buoy
    \ifdefstring{\navBuoyOption}{mooringbuoy}{
        \navBarrelBuoy{\navB}{\navA}{\navC}

        \pgfkeys{/markOptions/.cd, x=\navA - 0.5 * \navC, y=\navB + 1.35 * \navC, scaling=\navC * 0.5, top=circle}
        \navTopMark

    }

    % Location position
    \draw[fill=white] (\navA, \navB) circle (0.5 * \navC);

}


\newcommand{\navTopMark}[0]{
    % Set arguments
    \gdef\navTopX{\pgfkeysvalueof{/markOptions/x}}
    \gdef\navTopY{\pgfkeysvalueof{/markOptions/y}}
    \gdef\navTopS{\pgfkeysvalueof{/markOptions/scaling} * 1.5}
    \gdef\navTopSpace{\navTopS * 1.5}

    % Ball/Circle
    \ifdefstring{\navTopMarkings}{circle}{
        \draw[\navTopArea] (0.29 * \navTopS + \navTopX, \navTopS + \navTopY) circle (\navTopS * 0.75);
    }

    % Triangle up
    \ifdefstring{\navTopMarkings}{up}{
        \navTriangleUp{\navTopY}{\navTopX}{\navTopS}
    }

    % Box
    \ifdefstring{\navTopMarkings}{box}{
        \navBox{\navTopY}{\navTopX}{\navTopS}
    }

    % Cardinalmarks
    % North: both point up
    \ifdefstring{\navTopMarkings}{north}{
        % Bottom
        \navTriangleUp{\navTopY}{\navTopX}{\navTopS}

        % Top
        \navPositionNextMark{\navTopY}{\navTopX}
        \navTriangleUp{\navNextMarkY}{\navNextMarkX}{\navTopS}
    }

    % East: both point away from each other
    \ifdefstring{\navTopMarkings}{east}{
        % Bottom
        \navTriangleDown{\navTopY}{\navTopX}{\navTopS}

        % Top
        \navPositionNextMark{\navTopY}{\navTopX}
        \navTriangleUp{\navNextMarkY}{\navNextMarkX}{\navTopS}
    }

    % South: both point down
    \ifdefstring{\navTopMarkings}{south}{
        % Bottom
        \navTriangleDown{\navTopY}{\navTopX}{\navTopS}

        % Top
        \navPositionNextMark{\navTopY}{\navTopX}
        \navTriangleDown{\navNextMarkY}{\navNextMarkX}{\navTopS}
    }

    % West: both point to each other
    \ifdefstring{\navTopMarkings}{west}{
        % Bottom
        \navTriangleUp{\navTopY}{\navTopX}{\navTopS}

        % Top
        \navPositionNextMark{\navTopY}{\navTopX}
        \navTriangleDown{\navNextMarkY}{\navNextMarkX}{\navTopS}
    }
}


% Draw single triangle with relative coordinates
% Triangles: towards center
% Up:
% Left: (-0.87, -0.83) => (-0.58, 0.17)
% Right: (0.28, -1.17) => (0.57, -0.17)
% Offset: (0.29, 1)

% Down:
% Left: (-0.28, 1.17)
% Right: (0.87, 0.83)

% Arguments: y-Coord, x-Coord, scaling
\newcommand{\navTriangleUp}[3]{
    \gdef\navTriangleUpY{#1}
    \gdef\navTriangleUpX{#2}
    \gdef\navTriangleUpScaling{#3}

    \draw[\navTopArea] (-0.58 * \navTriangleUpScaling + \navTriangleUpX, 0.17 * \navTriangleUpScaling + \navTriangleUpY) --
    (0.57 * \navTriangleUpScaling + \navTriangleUpX, -0.17 * \navTriangleUpScaling + \navTriangleUpY) --
    (0.29 * \navTriangleUpScaling + \navTriangleUpX, \navTriangleUpScaling + \navTriangleUpY) -- cycle;
}

% Arguments: y-Coord, x-Coord
\newcommand{\navPositionNextMark}[2]{
    \gdef\navNextMarkY{1 * \navTopSpace + #1}
    \gdef\navNextMarkX{0.29 * \navTopSpace + #2}
}

% Arguments: y-Coord, x-Coord, scaling
\newcommand{\navTriangleDown}[3]{
    \gdef\navTriangleDownY{#1}
    \gdef\navTriangleDownX{#2}
    \gdef\navTriangleDownScaling{#3}

    \draw[\navTopArea] (-0.28 * \navTriangleDownScaling + \navTriangleDownX, 1.17 * \navTriangleDownScaling + \navTriangleDownY) --
    (0.87 * \navTriangleDownScaling + \navTriangleDownX, 0.83 * \navTriangleDownScaling + \navTriangleDownY) --
    (\navTriangleDownX, \navTriangleDownY) -- cycle;
}


% Box for cylindrical buoy
% Offset: (0.4, 2.15)
% Left Bottom:  (-0.1, 2.2) => (-0.5, 0.05)
% Left Top:     (0.2, 3.5)    => (-0.2, 1.35)
% Right Bottom: (0.9, 2)    => (0.5, -0.15)
% Right Top:    (1.75, 3.25)  => (0.85, 1.1)

% Arguments: y-Coord, x-Coord, scaling
\newcommand{\navBox}[3]{
    \gdef\navBoxY{#1}
    \gdef\navBoxX{#2}
    \gdef\navBoxScaling{#3}

    \draw[\navTopArea] (-0.5 * \navBoxScaling + \navBoxX, 0.05 * \navBoxScaling + \navBoxY) --
    (-0.2 * \navBoxScaling + \navBoxX, 1.35 * \navBoxScaling + \navBoxY) --
    (0.85 * \navBoxScaling + \navBoxX, 1.1 * \navBoxScaling + \navBoxY) --
    (0.5 * \navBoxScaling + \navBoxX, -0.15 * \navBoxScaling + \navBoxY) -- cycle;
}


% Arguments: y-Coord, x-Coord, scaling
\newcommand{\navBarrelBuoy}[3]{
    \gdef\navBarrelY{#1}
    \gdef\navBarrelX{#2}
    \gdef\navBarrelS{#3}

    % Left side
    \draw[\navBuoyArea] (-2 * \navBarrelS + \navBarrelX, \navBarrelY) -- (-1.5 * \navBarrelS + \navBarrelX, \navBarrelY) -- (-1.5 * \navBarrelS + \navBarrelX, 0.75 * \navBarrelS + \navBarrelY) --
    (-1.5 * \navBarrelS + \navBarrelX, 0.75 * \navBarrelS + \navBarrelY) arc[start angle=180, end angle=90, radius=\navBarrelS * 0.75cm] --
    % Right side
    (0.25 * \navBarrelS + \navBarrelX, 1.5 * \navBarrelS + \navBarrelY) --
    (0.25 * \navBarrelS + \navBarrelX, 1.5 * \navBarrelS + \navBarrelY) arc[start angle=90, end angle=0, radius=\navBarrelS * 0.75cm] --
    (1 * \navBarrelS + \navBarrelX, \navBarrelY) -- (1.5 * \navBarrelS + \navBarrelX, \navBarrelY) -- cycle;

}

